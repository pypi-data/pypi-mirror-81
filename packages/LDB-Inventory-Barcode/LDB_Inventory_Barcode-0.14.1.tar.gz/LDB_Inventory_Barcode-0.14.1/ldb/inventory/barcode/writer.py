# Copyright 2020 Alex Orange 
# 
# This file is part of LDB Inventory Barcode.
# 
# LDB Inventory Barcode is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# LDB Inventory Barcode is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with LDB Inventory Barcode.  If not, see
# <https://www.gnu.org/licenses/>.
#
# This code derives from python-barcode
#
# Copyright (c) 2017-2020 Hugo Osvaldo Barrera <hugo@barrera.io>, et al
# Copyright (c) 2010-2013 Thorsten Weimann
#
# python-barcode is licensed under the MIT License, contained in MIT-LICENSE.
# All modifications to python-barcode are licensed as described above. If you
# want MIT Licensed code, just get the original from python-barcode.

import gzip
import os
import xml.dom
from typing import BinaryIO

from ldb.inventory.barcode.version import version

try:
    import Image
    import ImageDraw
    import ImageFont
except ImportError:
    try:
        from PIL import Image, ImageDraw, ImageFont  # lint:ok
    except ImportError:
        import logging

        log = logging.getLogger("pyBarcode")
        log.info("Pillow not found. Image output disabled")
        Image = ImageDraw = ImageFont = None  # lint:ok

try:
    from reportlab.pdfgen import canvas as pdf_canvas
    from reportlab.lib.units import inch as pdf_inch
    from reportlab.lib.colors import white as pdf_white, black as pdf_black
except ImportError as e:
    pdf_canvas = None
    pdf_inch = None
    pdf_white = None
    pdf_black = None

    import logging

    log = logging.getLogger("pyBarcode")
    log.debug("reportlab not found. Pdf output disabled")


def mm2px(mm, dpi=300):
    return (mm * dpi) / 25.4


def pt2mm(pt):
    return pt * 0.352777778


def _set_attributes(element, **attributes):
    for key, value in attributes.items():
        element.setAttribute(key, value)


def create_svg_object(with_doctype=False):
    imp = xml.dom.getDOMImplementation()
    doctype = imp.createDocumentType(
        "svg",
        "-//W3C//DTD SVG 1.1//EN",
        "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd",
    )
    document = imp.createDocument(None, "svg", doctype if with_doctype else None)
    _set_attributes(
        document.documentElement, version="1.1", xmlns="http://www.w3.org/2000/svg"
    )
    return document


SIZE = "{0:.3f}mm"
COMMENT = "Autogenerated with python-barcode {}".format(version)
PATH = os.path.dirname(os.path.abspath(__file__))


class BaseWriter:
    """Baseclass for all writers.

    Initializes the basic writer options. Childclasses can add more
    attributes and can set them directly or using
    `self.set_options(option=value)`.

    Child classes should override the following methods as appropriate:
    * initialize
        Callback for initializing the inheriting writer.
    * paint_module
        Callback for painting one barcode module.
    * paint_text
        Callback for painting the text under the barcode.
    * finish
        Callback for doing something with the completely rendered output.
    """

    def __init__(self, dpi=300):
        self.dpi = dpi
        self.module_width = 10
        self.module_height = 10
        self.font_path = os.path.join(PATH, "fonts", "DejaVuSansMono.ttf")
        self.font_size = 10
        self.quiet_zone = 6.5
        self.background = "white"
        self.foreground = "black"
        self.text = ""
        self.human = ""  # human readable text
        self.text_distance = 5
        self.text_line_distance = 1
        self.center_text = True

    @property
    def font_size_dots(self):
        return self.font_size / 72 * self.dpi

    def initialize(self, code):
        """
        Initialize the writer.

        :parameters:
            code : String
                The raw code
        """
        pass

    def paint_module(self, x_position, y_position, width, height, color):
        """
        Paint one barcode module.

        :parameters:
            x_position : Float
                The x position of the module in dots
            y_position : Float
                The y position of the module in dots
            width : Float
                The width of the module in dots
            height : Float
                The width of the module in dots
            color : String
                The color of the module, typically "black" or "white"
        """
        pass

    def paint_text(self, x_position, y_position):
        """
        Paint the text under the barcode.

        :parameters:
            x_position : Float
                The x position of the text
            y_position : Float
                The y position of the text
        """
        pass

    def finish(self):
        """
        Do something with the completely rendered output.
        """
        pass

    def calculate_size(self, modules_per_line, number_of_lines):
        """Calculates the size of the barcode in pixel.

        :parameters:
            modules_per_line : Float
                Number of modules in one line.
            number_of_lines : Float
                Number of lines of the barcode.

        :returns: Width and height of the barcode in pixel.
        :rtype: Tuple
        """
        width = 2 * self.quiet_zone + modules_per_line * self.module_width
        height = 2.0 + self.module_height * number_of_lines
        number_of_text_lines = len(self.text.splitlines())
        if self.font_size and self.text:
            height += (
                pt2mm(self.font_size) / 2 * number_of_text_lines + self.text_distance
            )
            height += self.text_line_distance * (number_of_text_lines - 1)
        return int(mm2px(width, self.dpi)), int(mm2px(height, self.dpi))

    def save(self, filename, output):
        """Saves the rendered output to `filename`.

        :parameters:
            filename : String
                Filename without extension.
            output : String
                The rendered output.

        :returns: The full filename with extension.
        :rtype: String
        """
        raise NotImplementedError

    def set_options(self, options):
        """Sets the given options as instance attributes (only
        if they are known).

        :parameters:
            options : Dict
                All known instance attributes and more if the childclass
                has defined them before this call.

        :rtype: None
        """
        for key, val in options.items():
            key = key.lstrip("_")
            if hasattr(self, key):
                setattr(self, key, val)

    def render(self, code):
        """Renders the barcode to whatever the inheriting writer provides,
        using the registered callbacks.

        :parameters:
            code : List
                List of strings matching the writer spec
                (only contain 0 or 1).
        """
        self.initialize(code)
        ypos = 1.0
        for cc, line in enumerate(code):
            """
            Pack line to list give better gfx result, otherwise in can
            result in aliasing gaps
            '11010111' -> [2, -1, 1, -1, 3]
            """
            line += " "
            c = 1
            mlist = []
            for i in range(0, len(line) - 1):
                if line[i] == line[i + 1]:
                    c += 1
                else:
                    if line[i] == "1":
                        mlist.append(c)
                    else:
                        mlist.append(-c)
                    c = 1
            # Left quiet zone is x startposition
            xpos = self.quiet_zone
            bxs = xpos  # x start of barcode
            for mod in mlist:
                if mod < 1:
                    color = self.background
                else:
                    color = self.foreground
                # remove painting for background colored tiles?
                self.paint_module(
                    mm2px(xpos, self.dpi), mm2px(ypos, self.dpi),
                    mm2px(self.module_width * abs(mod), self.dpi),
                    mm2px(self.module_height, self.dpi),
                    color
                )
                xpos += self.module_width * abs(mod)
            bxe = xpos
            # Add right quiet zone to every line, except last line,
            # quiet zone already provided with background,
            # should it be removed completely?
            if (cc + 1) != len(code):
                self.paint_module(
                    mm2px(xpos, self.dpi), mm2px(ypos, self.dpi),
                    mm2px(self.quiet_zone, self.dpi),
                    mm2px(self.module_height, self.dpi),
                    self.background
                )
            ypos += self.module_height
        if self.text and self.paint_text is not None:
            ypos += self.text_distance
            if self.center_text:
                # better center position for text
                xpos = bxs + ((bxe - bxs) / 2.0)
            else:
                xpos = bxs
            self.paint_text(mm2px(xpos, self.dpi), mm2px(ypos, self.dpi))
        return self.finish()


class SVGWriter(BaseWriter):
    def __init__(self):
        super().__init__(dpi=25.4)
        self.compress = False
        self.with_doctype = True
        self._document = None
        self._root = None
        self._group = None

    def initialize(self, code):
        width, height = self.calculate_size(len(code[0]), len(code))
        self._document = create_svg_object(self.with_doctype)
        self._root = self._document.documentElement
        attributes = {
            "width": SIZE.format(width),
            "height": SIZE.format(height),
        }
        _set_attributes(self._root, **attributes)
        self._root.appendChild(self._document.createComment(COMMENT))
        # create group for easier handling in 3rd party software
        # like corel draw, inkscape, ...
        group = self._document.createElement("g")
        attributes = {"id": "barcode_group"}
        _set_attributes(group, **attributes)
        self._group = self._root.appendChild(group)
        background = self._document.createElement("rect")
        attributes = {
            "width": "100%",
            "height": "100%",
            "style": "fill:{}".format(self.background),
        }
        _set_attributes(background, **attributes)
        self._group.appendChild(background)

    def paint_module(self, x_position, y_position, width, height, color):
        element = self._document.createElement("rect")
        attributes = {
            "x": SIZE.format(x_position),
            "y": SIZE.format(y_position),
            "width": SIZE.format(width),
            "height": SIZE.format(height),
            "style": "fill:{};".format(color),
        }
        _set_attributes(element, **attributes)
        self._group.appendChild(element)

    def paint_text(self, x_position, y_position):
        # check option to override self.text with self.human (barcode as
        # human readable data, can be used to print own formats)
        if self.human != "":
            barcodetext = self.human
        else:
            barcodetext = self.text
        for subtext in barcodetext.split("\n"):
            element = self._document.createElement("text")
            attributes = {
                "x": SIZE.format(x_position),
                "y": SIZE.format(y_position),
                "style": "fill:{};font-size:{}pt;text-anchor:middle;".format(
                    self.foreground,
                    self.font_size,
                ),
            }
            _set_attributes(element, **attributes)
            text_element = self._document.createTextNode(subtext)
            element.appendChild(text_element)
            self._group.appendChild(element)
            y_position += self.font_size_dots + self.text_line_distance

    def finish(self):
        if self.compress:
            return self._document.toxml(encoding="UTF-8")
        else:
            return self._document.toprettyxml(
                indent=4 * " ", newl=os.linesep, encoding="UTF-8"
            )

    def save(self, filename, output):
        if self.compress:
            _filename = "{}.svgz".format(filename)
            f = gzip.open(_filename, "wb")
            f.write(output)
            f.close()
        else:
            _filename = "{}.svg".format(filename)
            with open(_filename, "wb") as f:
                f.write(output)
        return _filename

    def write(self, content, fp: BinaryIO):
        """Write `content` into a file-like object.

        Content should be a barcode rendered by this writer.
        """
        fp.write(content)


if Image is None:
    ImageWriter = None
else:

    class ImageWriter(BaseWriter):  # type: ignore
        format: str
        mode: str
        dpi: int

        def __init__(self, format="PNG", mode="RGB"):
            """Initialise a new write instance.

            :params format: The file format for the generated image. This parameter can
                take any value that Pillow accepts.
            :params mode: The colour-mode for the generated image. Set this to RGBA if
                you wish to use colours with transparency.
            """
            super().__init__()
            self.format = format
            self.mode = mode
            self.dpi = 300
            self._image = None
            self._draw = None

        def initialize(self, code):
            size = self.calculate_size(len(code[0]), len(code))
            self._image = Image.new(self.mode, size, self.background)
            self._draw = ImageDraw.Draw(self._image)

        def paint_module(self, x_position, y_position, width, height, color):
            size = [
                (x_position, y_position),
                (
                    x_position + width,
                    y_position + height,
                ),
            ]
            self._draw.rectangle(size, outline=color, fill=color)

        def paint_text(self, x_position, y_position):
            font = ImageFont.truetype(self.font_path, self.font_size * 2)
            for subtext in self.text.split("\n"):
                width, height = font.getsize(subtext)
                # determine the maximum width of each line
                pos = (
                    x_position - width // 2,
                    y_position - height // 2,
                )
                self._draw.text(pos, subtext, font=font, fill=self.foreground)
                y_position += self.font_size_dots / 2 + self.text_line_distance

        def finish(self):
            return self._image

        def save(self, filename, output):
            filename = "{}.{}".format(filename, self.format.lower())
            output.save(filename, self.format.upper())
            return filename

        def write(self, content, fp: BinaryIO):
            """Write `content` into a file-like object.

            Content should be a barcode rendered by this writer.
            """
            content.save(fp, format=self.format)


class ReportlabCanvasWriter(BaseWriter):
    def __init__(self, canvas, foreground=pdf_black):
        if pdf_canvas is None:
            raise Exception("You need to install reportlab in order to make "
                            "PDFs. Try installing with the pdf extra.")

        super().__init__()

        self.canvas = canvas

        self.dpi = pdf_inch

        self.foreground = foreground
        self.background = None

    def initialize(self, code):
        # TODO: Figure out how to do this right
        if self.foreground == 'black':
            self.foreground = pdf_black
        if self.background == 'white':
            self.background = None
        self.canvas_height = self.canvas._pagesize[1]


    def paint_module(self, x_position, y_position, width, height, color):
        y_position = self.canvas_height - y_position - height
        if color is not None:
            self.canvas.setFillColor(color)
            self.canvas.rect(x_position, y_position, width, height,
                             stroke=0, fill=1)

    def paint_text(self, x_position, y_position):
        y_position = self.canvas_height - y_position

        # check option to override self.text with self.human (barcode as
        # human readable data, can be used to print own formats)
        if self.human != "":
            barcodetext = self.human
        else:
            barcodetext = self.text

        font = 'Courier'

        text_object = self.canvas.beginText()
        text_object.setFont(font, self.font_size)
        text_object.setFillColor(self.foreground)
        text_object.setTextOrigin(x_position, y_position)

        for subtext in barcodetext.split("\n"):
            # TODO handle self.font_size
            offset = self.canvas.stringWidth(subtext, font, self.font_size) / 2
            text_object.setXPos(-offset)
            text_object.textLine(subtext)
            text_object.setXPos(offset)

        self.canvas.drawText(text_object)


class PdfWriter(ReportlabCanvasWriter):
    def __init__(self, file_, foreground=pdf_black):
        if pdf_canvas is None:
            raise Exception("You need to install reportlab in order to make "
                            "PDFs. Try installing with the pdf extra.")

        super().__init__(None)

        self.file_ = file_

    def initialize(self, code):
        width, height = self.calculate_size(len(code[0]), len(code))
        self.canvas = pdf_canvas.Canvas(self.file_, pagesize=(width, height))
        super().initialize(code)

    def finish(self):
        self.canvas.save()

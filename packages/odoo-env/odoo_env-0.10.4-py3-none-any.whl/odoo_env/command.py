# -*- coding: utf-8 -*-
from odoo_env.__init__ import __version__
import os
from odoo_env.messages import Msg
import subprocess

msg = Msg()


class Command:
    def __init__(self, parent, command=False, usr_msg=False, args=False,
            client_name=False):
        """
        :param parent: El objeto OdooEnv que lo contiene por los parametros
        :param command: El comando a ejecutar en el shell
        :param usr_msg: El mensaje a mostrarle al usuario
        :param args: Argumentos para chequear, define si se ejecuta o no
        :return: El objeto Comando que se ejecutara luego
        """
        self._parent = parent
        self._command = command
        self._usr_msg = usr_msg
        self._args = args
        self._client_name = client_name

    def check(self):
        # si no tiene argumentos para chequear no requiere chequeo,
        # lo dejamos pasar
        if not self._args:
            return True

        # le pasamos el chequeo al objeto especifico
        return self.check_args()

    def check_args(self):
        raise NotImplementedError

    def execute(self):
        cmd = self.command
        self.subrpocess_call(cmd)

    def subrpocess_call(self, params, shell=False):
        """ Run command or command list with arguments.  Wait for commands to
            complete
            If args.verbose is true, prints command
            If any errors stop list execution and returns error
            if shell=True go shell mode (only for --cron-jobs)

        :param params: command or command list
        :return: error return
        """
        # if not a list convert to a one element list
        params = params if isinstance(params, list) else [params]

        # traverse list executing shell commands
        for _cmd in params:
            # if shell = True we do no split
            cmd = _cmd if shell else _cmd.split()
            if self._parent.verbose:
                msg.run(' ')
                if shell:
                    msg.run(cmd)
                else:
                    msg.run(' '.join(cmd))
                msg.run(' ')
            ret = subprocess.call(cmd, shell=shell)
            if ret:
                return msg.err('The command {} returned with {}'.format(
                    cmd,
                    str(ret)))

    @property
    def args(self):
        return self._args

    @property
    def usr_msg(self):
        return self._usr_msg

    @property
    def command(self):
        return self._command


class CreateGitignore(Command):
    def execute(self):
        # crear el gitignore en el archivo que viene del comando
        values = ['.idea/\n', '*.pyc\n', '__pycache__\n']
        with open(self._command, 'w') as f:
            for value in values:
                f.write(value)


class MakedirCommand(Command):
    def check_args(self):
        # si el directorio existe no lo creamos
        return not os.path.isdir(self._args)


class ExtractSourcesCommand(Command):
    @staticmethod
    def check_args():
        return True


class CloneRepo(Command):
    def check_args(self):
        # si el directorio no existe dejamos clonar
        return not os.path.isdir(self._args)


class PullRepo(Command):
    def check_args(self):
        # si el directorio existe dejamos pulear
        return os.path.isdir(self._args)


class PullImage(Command):
    @staticmethod
    def check_args():
        return True


class CreateNginxTemplate(Command):
    def check_args(self):
        # si el archivo existe no lo dejamos pasar
        return not os.path.isfile(self._args)

    def execute(self):
        # leer el nginx.conf
        with open('/usr/local/nginx.conf', 'r') as f:
            conf = f.read()

        # poner el nombre del cliente en el config
        conf = conf.replace('$client$', self._client_name)

        with open(self._command, 'w') as f:
            f.write(conf)


class WriteConfigFile(Command):
    def check_args(self):
        return True

    def execute(self):
        # leer los repositorios instalados en sources
        arg = self._args
        client = arg['client']

        # obtener los repositorios que hay en sources
        repos = next(os.walk(client.sources_dir))[1]
        # agregarle los directorios dentro de la imagen
        repos = ['/opt/odoo/custom-addons/' + x for x in repos]

        with open(client.config_file, 'w') as f:
            txt = '; Configuration file generated by odoo-env v%s\n\n'
            f.write(txt % __version__)
            f.write('[options]\n')
            f.write('addons_path = %s' % ','.join(repos) + '\n')
            f.write('data_dir = %s \n' % arg['data_dir'])
            f.write('workers = %s\n' % arg['workers'])
            f.write('max_cron_threads = %s\n' % arg['max_cron_threads'])
            f.write('limit_request = %s\n' % arg['limit_request'])
            f.write('limit_memory_soft = %s\n' % arg['limit_memory_soft'])
            f.write('limit_memory_hard = %s\n' % arg['limit_memory_hard'])
            f.write('limit_time_cpu = %s\n' % arg['limit_time_cpu'])
            f.write('limit_time_real = %s\n' % arg['limit_time_real'])


class MessageOnly(Command):
    @staticmethod
    def check_args(self):
        """ Siempre lo dejamos pasar
        """
        return True

    @staticmethod
    def execute():
        pass

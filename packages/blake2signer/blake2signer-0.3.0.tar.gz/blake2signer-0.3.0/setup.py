# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['blake2signer', 'blake2signer.tests']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'blake2signer',
    'version': '0.3.0',
    'description': 'A library use Blake2 in keyed hashing mode to sign and verify data',
    'long_description': '# Blake2Signer\n\nThe goal of this module is to provide a simple way to securely sign data using Blake2 in keyed hashing mode (read more about that in the [hashlib docs](https://docs.python.org/3/library/hashlib.html#blake2)).\n \n The main use case is to sign cookies or similar data. There are much better packages for other use cases or more general use cases so if you feel this module doesn\'t satisfy your needs consider using "itsdangerous", Django\'s signer, "pypaseto", "pyjwt" or others like those. My idea is to keep this module as simple as possible without much room to become a *footgun*.\n\nThis project began initially as a Gist but I decided to create a package because I think it can be useful as a small (~500 LoC), simple (quite straightforward) and fast data signer (see more below).\n\n## Goals\n\n* Be simple and straightforward.\n* Follow [semver](https://semver.org/).\n* Be always typed.\n* No dependencies (besides dev).\n* 100% coverage.\n\n### Secondary goals\n\n* If possible, maintain current active Python versions (3.7+).\n\n## Requirements\n\n* Python 3.7+\n\n## Usage\n\nThis module provides three classes:\n\n* `Blake2Serializer`: a high-level signer class that handles data serialization, compression and encoding along with signing and timestamped signing.\n* `Blake2Signer`: a low-level signer class that simply salts, signs and verifies data as bytes.\n* `Blake2TimestampSigner`: a low-level signer class that simply salts, signs and verifies timestamped data as bytes.\n\nYou can\'t mix and match signers, and that\'s on purpose. This means that unsigning a stream signed by Blake2Signer using\nBlake2TimestampSigner may result in corrupt data and/or an error checking the timestamp (considering that the key and person is the same for both), and the same goes for the other way around.\n\nYou should generally go for the high-level signer class.\n\nIn all classes you can choose between blake2b (default) or blake2s as hasher and change the digest size with a secure minimum enforced (defaults to the maximum size for the hasher in the low-level classes and to 16 bytes for the high-level ones). The secret/key is enforced to be of a secure minimum size, where high-level classes have no size limit but low-level ones do (depending on the hasher).\n\n### Examples\n\nThe following examples are working code and should run as-is.\n\n#### Tl; Dr\n\n```python\n"""Tl;dr example."""\n\nfrom datetime import timedelta\n\nfrom blake2signer import Blake2Serializer\n\nsecret = b\'secure-secret-that-nobody-knows!\'\n# some arbitrary data to sign\ndata = {\'message\': \'attack at dawn\', \'extra\': [1, 2, 3, 4]}\n\n# Define same signer to `dumps` and `loads`.\nsigner = Blake2Serializer(\n    secret,\n    max_age=timedelta(days=1),\n    person=b\'message-cookie-signer\',\n)\n\n# Sign and i.e. store the data in a cookie\nsigned = signer.dumps(data, use_compression=True)\ncookie = {\'data\': signed}\n\n# To verify simply use loads: you will either get the data or a\n# `SignerError` subclass exception.\nunsigned = signer.loads(cookie.get(\'data\', \'\'))\nprint(unsigned[\'message\'], unsigned[\'extra\'])  # attack at dawn [1, 2, 3, 4]\n```\n\n#### High level classes\n\nThis is probably what you want to use :)\n\nBoth the *secret* and *personalisation* parameters are derived so they have no length limit. Input data can always be arbitrarily long.\n\nAs a general rule of thumb if you have highly compressible data such as human readable text, then you should enable compression. Otherwise when dealing with somewhat random data compression won\'t help much (but probably won\'t hurt either unless you\'re dealing with a huge amount of data).\n\nWhenever possible set a *personalisation string* which can be any arbitrarily long string. For example if you use a signer for cookies set something like `b\'cookies-signer\'` or if you use it for some user-related data signing it could be `b\'user-data-signer\'`. This personalisation string helps defeating the abuse of a signed stream for different signers that share the same key. See an example of this below and read more about it in the [hashlib docs](https://docs.python.org/3/library/hashlib.html#personalization).\n\n```python\n"""Usage examples."""\n\nfrom datetime import timedelta\n\nfrom blake2signer import Blake2Serializer\nfrom blake2signer import errors\n\n# Simple data serialization and signing\nsecret = b\'ZnVja3RoZXBvbGljZQ\'\ndata = [{\'a\': \'b\'}, 1] * 10000  # some big data structure\nprint(len(data))  # 20000\n\nsigner = Blake2Serializer(secret)  # without timestamp nor compression\nsigned = signer.dumps(data)\nprint(len(signed))  # 160044\n\nunsigned = signer.loads(signed)\nprint(data == unsigned)  # True\n\nsigner = Blake2Serializer(  # with timestamp\n    secret,\n    max_age=timedelta(weeks=1),\n)\nsigned = signer.dumps(data, use_compression=True)  # with compression\nprint(len(signed))  # 412  # compression helped reducing size heavily\n\nunsigned = signer.loads(signed)\nprint(data == unsigned)  # True\n\nsigner = Blake2Serializer(  # with timestamp and personalisation\n    secret,\n    max_age=timedelta(weeks=1),\n    person=b\'my-cookie-signer\',\n)\ntry:\n    signer.loads(signed)\nexcept errors.InvalidSignatureError as exc:\n    print(exc)  # signature is not valid\n# Using the `person` parameter made the sig to fail, thus protecting signed\n# data to be loaded incorrectly.\n\nsigned = signer.dumps(data, use_compression=True)  # with compression\nprint(len(signed))  # 412  # compression helped reducing size heavily\n\nunsigned = signer.loads(signed)\nprint(data == unsigned)  # True\n```\n\n#### Low level classes\n\nYou probably don\'t want to use these ones unless you are quite sure you do.\n\nNote that *key* and *personalisation* parameters are NOT derived and are used as-is, so algorithm size limits apply. Input data can always be arbitrarily long.\n\n```python\n"""Usage examples."""\n\nfrom blake2signer import Blake2Signer\nfrom blake2signer import Blake2TimestampSigner\n\n\n# Low level data signing (for bytes data only)\nkey = b\'ZnVja3RoZXBvbGljZQ\'\ndata = b\'facundo castro presente\'\n\nsigner = Blake2Signer(key)  # without timestamp\nsigned = signer.sign(data)\nprint(len(signed))  # 103\n\nunsigned = signer.unsign(signed)\nprint(data == unsigned)  # True\n\nsigner = Blake2TimestampSigner(key)  # with timestamp\nsigned = signer.sign(data)\nprint(len(signed))  # 107\n\nunsigned = signer.unsign(signed, max_age=10)\nprint(data == unsigned)  # True\n\n# Using Blake2s instead of Blake2b\nsigner = Blake2Signer(key, hasher=Blake2Signer.Hashers.blake2s)\nsigned = signer.sign(data)\nprint(len(signed))  # 63\n\nunsigned = signer.unsign(signed)\nprint(data == unsigned)  # True\n```\n\n#### Wrong usage examples\n\nThis section is meant to describe how signers can be misused so you can avoid the mistakes described here.\n\n```python\n"""Wrong usage examples."""\n\nfrom blake2signer import Blake2Signer\nfrom blake2signer import Blake2TimestampSigner\nfrom blake2signer.errors import ExpiredSignatureError\nfrom blake2signer.errors import InvalidSignatureError\n\n# Let\'s mix and match, what could go wrong? spoiler: everything!\nkey = b\'ZnVja3RoZXBvbGljZQ\'\ndata = b\'#ACAB\'\n\nsigner = Blake2Signer(key)\nt_signer = Blake2TimestampSigner(key)\n\ntry:\n    t_signer.unsign(signer.sign(data), max_age=1)\nexcept ExpiredSignatureError as exc:\n    print(repr(exc))\n# We see an exception because since the signature is OK the timestamped signer\n# is considering the 4 bytes `b\'ACAB\'` as a timestamp which gives us\n# 2004-09-11T15:17:38, way in the past. Is this an issue with the signer? NO.\n# As stated before, one must be careful of NOT mixing and matching things.\n\nsigner.unsign(t_signer.sign(data))  # b\'...#ACAB\'\n# This time we don\'t even get an exception because all is OK for the signer,\n# but the recovered data is wrong! It contains the timestamp from the timestamp\n# signer.\n\n# When using different signers for different things, its a good idea to use\n# the personalisation parameter which prevents these situations:\nsigner = Blake2Signer(key, person=b\'1234\')\nsigner.unsign(signer.sign(data))  # b\'#ACAB\'\n\ntry:\n    signer.unsign(t_signer.sign(data))\nexcept InvalidSignatureError as exc:\n    print(repr(exc))\n# Even though the key/secret is the same, the personalisation parameter changes\n# the hashing output thus changing the signature. This is very useful to\n# prevent these situations and should be implemented whenever used. It doesn\'t\n# have to be random nor secret nor too long, it just needs to be unique for\n# the usage. There\'s a limit to its size in the low level classes but the high\n# level classes derives the value so it has no practical limit.\n```\n\nThe moral of the story is: always sign and unsign using the exact same signer with the exact same parameters (there aren\'t many anyway), and use the personalisation parameter whenever you can.\n\n#### Real use case example\n\nSign cookies in a FastAPI/Starlette middleware.\n\n```python\n"""Sample use case: sign cookies in a FastAPI/Starlette middleware."""\n\nfrom datetime import timedelta\n\nfrom fastapi import Request\nfrom fastapi import Response\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.middleware.base import RequestResponseEndpoint\n\nfrom blake2signer import Blake2Serializer\nfrom blake2signer.errors import DecodeError\n\n# from .messages import Messages  # Some class that has the data we want to sign\nclass Messages:\n    \n    def to_dict(self) -> dict:\n        pass\n\n    @classmethod\n    def from_dict(cls, data: dict) -> \'Messages\':\n        pass\n\n# In this example, that class can be converted to/read from dict.\n# It doesn\'t need to be exactly a dict but any Python type that\n# can be JSON encodable. Since Python classes are already dicts\n# (unless they use `__slots__`), this is the most convenient portable\n# way. DO NOT USE PICKLE!! ITS UNSAFE AND LEADS TO CODE EXECUTION!\n\nSECRET_KEY: bytes = \'myverysecretsecret\'.encode()\nCOOKIE_TTL: timedelta = timedelta(days=5)\nCOOKIE_NAME: str = \'my_cookie\'\n\n\nclass CookieHTTPMiddleware(BaseHTTPMiddleware):\n\n    @property\n    def _signer(self) -> Blake2Serializer:\n        return Blake2Serializer(\n            SECRET_KEY,\n            max_age=COOKIE_TTL,\n            person=b\'cookie_http_middleware\',\n        )\n    \n    def get_cookie_data(self, request: Request) -> Messages:\n        signed_data = request.cookies.get(COOKIE_NAME, \'\')\n        messages_data = self._signer.loads(signed_data)  # may raise DecodeError\n        messages = Messages.from_dict(messages_data)\n        return messages\n\n    def set_cookie_data(self, messages: Messages, response: Response) -> None:\n        data = messages.to_dict()\n        signed_data = self._signer.dumps(data, use_compression=True)\n        response.set_cookie(\n            COOKIE_NAME,\n            value=signed_data,\n            max_age=int(COOKIE_TTL.total_seconds()),\n            secure=True,\n            httponly=True,\n            samesite=\'strict\',\n        )\n\n    async def dispatch(\n        self,\n        request: Request,\n        call_next: RequestResponseEndpoint,\n    ) -> Response:\n        try:\n            request.state.messages = self.get_cookie_data(request)\n        except DecodeError:  # some tampering, maybe we changed the secret...\n            request.state.messages = Messages()\n\n        response = await call_next(request)\n\n        # You may want to implement some change detection mechanism to avoid\n        # writing cookies in every response.\n        # if changed(request.state.messages):\n        self.set_cookie_data(request.state.messages, response)\n\n        return response\n```\n\n## Comparison with other libs\n\nIt\'s easy to compare this lib to, say, [itsdangerous](https://itsdangerous.palletsprojects.com/en/1.1.x) and [django](https://www.djangoproject.com).\n \n Regarding **itsdangerous** (1.1.0), I found this lib to be *marginally faster* (~3%) when compared to it using blake2b or blake2s, *quite faster* regarding sha256 (~55%), 384 (~15%) and 512 (~15%) and *slower* regarding sha1 (~15%) (this is most likely due to CPU instructions optimization).\n\n Regarding **django** (3.1.2), I found this lib to be *quite faster* (~17%) when compared to it using blake2b or blake2s, *incredibly faster* regarding sha256 (~92%), 384 (~55%) and 512 (~55%) and *marginally faster* regarding sha1 (~4%). I have no idea what\'s going on with Django! It seems its doing too many additional operations. Additionally its Signer doesn\'t handle arbitrary bytes well (it breaks raising `BadSignature` if you use `datab` below, so it needs `datas`).\n\n```python\n"""Timing comparison."""\n\nimport json\nfrom hashlib import blake2b\nfrom hashlib import sha1\nfrom hashlib import sha256\nfrom hashlib import sha384\nfrom hashlib import sha512\n\nfrom django.core import signing\nfrom itsdangerous import Signer\nfrom itsdangerous import URLSafeSerializer\n\nfrom blake2signer import Blake2Serializer\nfrom blake2signer import Blake2Signer\n\nsecret = b\'1\' * 16\ndata = [{\'a\': \'b\'}, 1] * 100000  # some big data structure\ndatas = json.dumps(data)\ndatab = datas.encode()\n\nb2s = Blake2Signer(secret)\nid_b2 = Signer(secret, digest_method=blake2b)\nid_s1 = Signer(secret, digest_method=sha1)\nid_s256 = Signer(secret, digest_method=sha256)\nid_s384 = Signer(secret, digest_method=sha384)\nid_s512 = Signer(secret, digest_method=sha512)\ndjs_b2 = signing.Signer(secret, algorithm=\'blake2b\')\ndjs_s1 = signing.Signer(secret, algorithm=\'sha1\')\ndjs_s256 = signing.Signer(secret, algorithm=\'sha256\')\ndjs_s384 = signing.Signer(secret, algorithm=\'sha384\')\ndjs_s512 = signing.Signer(secret, algorithm=\'sha512\')\n\n# Using ipython:\n%timeit b2s.unsign(b2s.sign(datab))\n%timeit id_b2.unsign(id_b2.sign(datab))\n%timeit id_s1.unsign(id_s1.sign(datab))\n%timeit id_s256.unsign(id_s256.sign(datab))\n%timeit id_s384.unsign(id_s384.sign(datab))\n%timeit id_s512.unsign(id_s512.sign(datab))\n%timeit djs_b2.unsign(djs_b2.sign(datas))\n%timeit djs_s1.unsign(djs_s1.sign(datas))\n%timeit djs_s256.unsign(djs_s256.sign(datas))\n%timeit djs_s384.unsign(djs_s384.sign(datas))\n%timeit djs_s512.unsign(djs_s512.sign(datas))\n\nb2ss = Blake2Serializer(secret)\nid_b2s = URLSafeSerializer(secret, signer_kwargs={\'digest_method\': blake2b})\n\n%timeit b2ss.loads(b2ss.dumps(data, use_compression=True))\n%timeit id_b2s.loads(id_b2s.dumps(data))\n```\n\n## Notice\n\nI\'m not a cryptoexpert, so there are some things that remain to be confirmed:\n\n* If an attacker can control some part (or all) of the input data, is it possible for them to guess the secret key or provoke a DoS given a huge amount of attempts? (assuming the key is long enough to prevent bruteforcing in the first place, which it should since I set the minimum key size to 128b).\n  > I think it is not possible but I would like an expert answer. I checked the code of different signers such as Itsdangerous, Django, etc. and they all do pretty much the same as I except they use the hmac lib.\n\n* I always assume that no attacker can influence the instantiation of the classes, thus they can\'t change any setting. If someone would break all of the given recommendations and somehow manage to get attacker-controlled data to class instantiation, which settings an attacker may change to break the security of this implementation and guess the secret key? This is more of an exercise but a fun one.\n  > I think that `Blake2Serializer` class is the the best target that allows more room to play since it deals with many layers: serialization, compression, encoding...\n\n## License\n\n**Blake2Signer** is made by [HacKan](https://hackan.net) under MPL v2.0. You are free to use, share, modify and share modifications under the terms of that [license](LICENSE).  Derived works may link back to the canonical repository: https://gitlab.com/hackancuba/blake2signer.  \n\n    Copyright (C) 2020 HacKan (https://hackan.net)\n    This Source Code Form is subject to the terms of the Mozilla Public\n    License, v. 2.0. If a copy of the MPL was not distributed with this\n    file, You can obtain one at https://mozilla.org/MPL/2.0/.\n',
    'author': 'HacKan',
    'author_email': 'hackan@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://gitlab.com/hackancuba/blake2signer',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)

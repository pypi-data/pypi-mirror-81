"""BrutePwn
A utility for trying something in remote many times.
This function is useful when, for example:
 - leak canary/libc/stack/pie in forked server
 - guess little entropy of address (i.e. main_arena --> global_max_fast)
 - SQLi to leak something byte by byte (i.e. blind sqli)
"""
import queue
import threading
import time

def brute_remote(func, iterator=None, cond=None, interval=0.5, threaded=True):
    """
    `func` is a function that receives an argument and returns a result.
    The argument is the value generated by `iterator`.
    If `iterator` is None, an infinite iterator which generates
    loop counters is used.
    `cond` must be a function or lambda which receives the result
    of `func` as its argument. If `cond` is None, the loop won't
    break until `iterator` ends. `cond` isn't used when threaded is True.
    This function returns the list of results returned by `func`.
    
    Args:
       func (function) : Function to attack to / leak from the server
       iterator (iter) : Iterator which generates arguments for `func`
       cond (lambda)   : Constraints to break the loop
       interval (float): Time to sleep in the iterator
       threaded (bool) : Use thread or not
    """
    rs = []
    if threaded:
        # with thread
        ts = []
        qq = queue.Queue()
        
        for i in iterator:
            t = threading.Thread(
                target = lambda q, x: q.put(func(x)),
                args = (qq, i)
            )
            ts.append(t)
            t.start()
            time.sleep(interval)
        
        for t in ts:
            t.join()

        while not qq.empty():
            rs.append(qq.get())
    
    else:
        # without thread
        for i in iterator:
            r = func(i)
            rs.append(r)
            if cond is not None and cond(r):
                break
            time.sleep(interval)
    return rs

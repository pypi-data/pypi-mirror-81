<?xml version="1.0" encoding="UTF-8"?>

<deviceconf name="PIC16F15244">
    <register name="DEVICE_CONFIG_MAJOR" value="1"/>
    <register name="DEVICE_CONFIG_MINOR" value="6"/>
    <register name="DEVICE_CONFIG_BUILD" value="49"/>
    <register name="CONTENT_LENGTH" value="0"/>
    <register name="CONTENT_CHECKSUM" value="0"/>
    <register name="INSTANCE" value="0"/>
    <register name="INTERFACE_TYPE" value="0x04"/>
    <register name="DEVICE_VARIANT" value="0x00"/>
    <register name="BLOB" value="">
        <blob>
            <!--Source code used to generate this blob:
        class DeviceDefinition(PicDevice):
            """
                PIC device definition
            """
            # ICSP interface clock period in nano seconds
            ICSP_CLOCK_PERIOD_NS = 200

            # Debugger model specifies how the Python stack interacts with the debugger over USB
            DEBUGGER_MODEL = PythonScriptedPic16Debugger
            # Programming interface specifies how the debugger tool interacts with the target device
            PROGRAMMING_INTERFACE = ProgInterfaceIcspC8D24
            # Debugging interface specifies how the debugger tool interacts with the debug executive
            DEBUGGING_INTERFACE = DebugExecApiVx

            # Flash properties for this device
            FLASH_WRITE_BYTES_PER_PAGE = 64

            # ICSP programming command-set for this device. Commands from programming spec.
            LOAD_PC_COMMAND = 0x80
            BULK_ERASE_COMMAND = 0x18
            ROW_ERASE_COMMAND = 0xF0
            LOAD_DATA_NVM_COMMAND = 0x00
            LOAD_DATA_NVM_INC_COMMAND = 0x02
            READ_DATA_NVM_COMMAND = 0xFC
            READ_DATA_NVM_INC_COMMAND = 0xFE
            ADDRESS_INC = 0xF8
            INTERNALLY_TIMED_PROG_COMMAND = 0xE0
            INCREMENT_ADDRESS_COMMAND = 0xF8

            # Extra commands for DE access
            MAE_COMMAND = 0xC4
            MAE_IEDE = 0x006355
            MAE_DELAY_MS = 3

            # Delays for internally timed programming
            BULK_ERASE_DELAY_US = 8400
            ROW_ERASE_DELAY_US = 2800
            PAGE_PROGRAMMING_DELAY_US = 2800
            WRITE_CONFIG_WORD_DELAY_US = 5600
            DE_ERASE_DELAY_US = 14000
            EEPROM_PROGRAMMING_DELAY_US = WRITE_CONFIG_WORD_DELAY_US
            ID_PROGRAMMING_DELAY_US = WRITE_CONFIG_WORD_DELAY_US
            WRITE_DE_PAGE_DELAY_US = WRITE_CONFIG_WORD_DELAY_US

            # ICSP command level timing
            TDLY_US = 1

            # Program counter/address values
            DEFAULT_ADDRESS_FOR_BULK_ERASE_B = 0x8000*2 # This will erase flash, Configuration words and User ID
            DEVICE_ID_ADDRESS_B = 0x8006*2
            DEBUG_VECT_ADDRESS_B = 0x8004*2
            DEBUG_EXEC_ADDRESS_B = 0x8600*2
            DEBUG_VECT_VALUE = 0x2820  # TODO - find out where these magic numbers come from
                                       # useful hint: This seems to be a GOTO 0x20 instruction to be loaded into
                                       # debug interrupt vector. 0x20 is the start of the second page (of whatever
                                       # section PCLATH points to), which seems a likely place for a debug exec?
                                       # if so: TODO - figure out where these mundane numbers come from

            def __init__(self):
                PicDevice.__init__(self)

            def enter_tmod(self):
                """
                Enter TMOD.
                Puts the PIC device into its "Programming mode"
                """
                # MCLR high
                self.hw.set_mclr_high()
                # Have to wait for a minimum of TENTS = 100ns
                self.board.delay_us(1)

                # ICSP pins low
                self.hw.set_all_pins_low()

                # MCLR low
                self.hw.set_mclr_low()
                # Have to wait for a minimum of TENTH = 250us
                self.board.delay_us(250)

                # Send the MCHP string, backwards
                self.prog.write_string_literal('MCHP'[::-1])

            def exit_tmod(self):
                # MCLR back high
                self.hw.set_mclr_high()
                # Have to wait for a minimum of TEXIT = 1us
                self.board.delay_us(1)

            def hold_in_reset(self):
                # Tristate
                self.hw.set_clk_in_data_in()
                # MCLR low
                self.hw.set_mclr_low()

            def release_from_reset(self):
                # Tristate
                self.hw.set_clk_in_data_in()
                # MCLR high
                self.hw.set_mclr_high()

            def read_id(self):
                """
                Read the device ID from the PIC
                """
                # Set address to configuration space
                self.prog.command(self.LOAD_PC_COMMAND)
                # PIC16 devices takes word addresses
                self.prog.payload(self.DEVICE_ID_ADDRESS_B // 2)
                # Read a word from NVM
                self.prog.command(self.READ_DATA_NVM_COMMAND)
                device_id = self.prog.read_data_word()
                return device_id

            def bulk_erase(self, byte_address=None):
                """
                Erase the entire flash area
                :param byte_address: address for the bulk erase, see programming spec for the target device for info on which memory sections will be erased
                """
                if byte_address is None:
                    byte_address=self.DEFAULT_ADDRESS_FOR_BULK_ERASE_B
                # Set address to configuration space
                self.prog.command(self.LOAD_PC_COMMAND)
                # This device uses word addressing
                self.prog.payload(byte_address // 2)

                # Internally timed erase command
                self.prog.command(self.BULK_ERASE_COMMAND)
                self.board.delay_us(self.BULK_ERASE_DELAY_US)
                
                #Cycle the tmod to ensure correct erasure 
                self.exit_tmod()
                self.enter_tmod()


            def write_flash_page(self, byte_address, words):
                """
                Write one flash page to the PIC
                :param byte_address: start address of the page to write
                :param words: number of words to write
                Data is taken indirectly from the data buffer
                """
                self.prog.command(self.LOAD_PC_COMMAND)
                # PIC16 devices uses word addressing
                self.prog.payload(byte_address // 2)

                # Loop through all but the last word
                for word in range(words - 1):
                    self.prog.command(self.LOAD_DATA_NVM_INC_COMMAND)
                    self.prog.write_data_word()

                # Write last word with no increment
                self.prog.command(self.LOAD_DATA_NVM_COMMAND)
                self.prog.write_data_word()

                # Timed flash programming procedure
                self.prog.command(self.INTERNALLY_TIMED_PROG_COMMAND)
                self.board.delay_us(self.PAGE_PROGRAMMING_DELAY_US)

            def read_flash(self, byte_address, words):
                """
                Reads a block of flash from the PIC
                :param byte_address: start address to read from
                :param words: number of words to read
                Data is sent indirectly to the data buffer
                """
                # Set the address to read from
                self.prog.command(self.LOAD_PC_COMMAND)
                # PIC16 devices uses word addressing
                self.prog.payload(byte_address // 2)
                # Loop through range, reading words
                for word in range(words):
                    self.prog.command(self.READ_DATA_NVM_INC_COMMAND)
                    self.prog.read_data_word()

            def read_config_word(self, byte_address):
                """
                Reads one config word from config space.
                :param byte_address: address of the word
                :return:
                """
                self.read_flash(byte_address, 1)

            def write_config_word(self, byte_address):
                """
                Writes one word to the config space
                :param byte_address: byte address to write
                :return:
                """
                # Set the address to write to
                self.prog.command(self.LOAD_PC_COMMAND)
                # PIC16 devices uses word addressing
                self.prog.payload(byte_address // 2)
                # Write data into NVM
                self.prog.command(self.LOAD_DATA_NVM_COMMAND)
                self.prog.write_data_word()
                # Internally timed write procedure
                self.prog.command(self.INTERNALLY_TIMED_PROG_COMMAND)
                self.board.delay_us(self.WRITE_CONFIG_WORD_DELAY_US)

            def write_user_id_word(self, byte_address):
                """
                Writes one word to the user_id space
                :param byte_address: byte address to write
                :return:
                """
                # Identical to write config words
                self.write_config_word(byte_address)

            def write_debug_vector(self):
                """
                Writes the debug vector (literal)
                """

                # Enter programming mode
                self.enter_tmod()

                # Set address to configuration space
                self.prog.command(self.LOAD_PC_COMMAND)
                # PIC16 devices uses word addressing
                self.prog.payload(self.DEBUG_VECT_ADDRESS_B // 2)

                # Write literal
                self.prog.command(self.LOAD_DATA_NVM_COMMAND)
                self.prog.payload(self.DEBUG_VECT_VALUE)
                # Commit to flash
                self.prog.command(self.INTERNALLY_TIMED_PROG_COMMAND)
                self.board.delay_us(self.PAGE_PROGRAMMING_DELAY_US)

                # Leave programming mode
                self.exit_tmod()

            def enter_debug(self):
                """
                Enters DEBUG state on the PIC
                Note: The Debug Executive must be in place first!
                """
                # Put the debug vector in place
                self.write_debug_vector()
                # MCLR low
                self.hw.set_mclr_low()
                self.board.delay_ms(100)
                # ICSP pins low
                self.hw.set_all_pins_low()
                # MCLR high
                self.hw.set_mclr_high()
                self.board.delay_ms(100)
                # ICSP input
                self.hw.set_clk_in_data_in()
                # MCLR low
                self.hw.set_mclr_low()
                self.board.delay_ms(100)
                # MCLR high
                self.hw.set_mclr_high()
                self.board.delay_ms(100)

            def erase_de(self, byte_address, words):
                """
                Erase the Debug Executive
                """
                self.prog.command(self.LOAD_PC_COMMAND)
                self.prog.payload(self.DEBUG_EXEC_ADDRESS_B // 2)
                self.enable_de_access()

                # Internally timed erase command
                self.prog.command(self.BULK_ERASE_COMMAND)
                self.board.delay_us(self.DE_ERASE_DELAY_US)

            def enable_de_access(self):
                """
                Enable access to the Debug Executive memory
                """
                self.prog.command(self.MAE_COMMAND)
                self.prog.payload(self.MAE_IEDE)
                self.board.delay_ms(self.MAE_DELAY_MS)

            def write_de_page(self, byte_address, words):
                """
                Write a page of the Debug Executive
                """
                # Set the address to write to
                self.prog.command(self.LOAD_PC_COMMAND)
                # PIC16 devices uses word addressing
                self.prog.payload(byte_address // 2)
                self.enable_de_access()

                # Loop through all but the last word
                for word in range(words - 1):
                    self.prog.command(self.LOAD_DATA_NVM_INC_COMMAND)
                    self.prog.write_data_word()

                # Write last word with no increment
                self.prog.command(self.LOAD_DATA_NVM_COMMAND)
                self.prog.write_data_word()

                # Timed flash programming procedure
                self.prog.command(self.INTERNALLY_TIMED_PROG_COMMAND)
                self.board.delay_us(self.WRITE_DE_PAGE_DELAY_US)
        -->
            <token>LIST</token>
            <entry>
                <type>PRIMITIVE_SEQUENCE</type>
                <id>12</id>
                <data>0x54, 0x00, 0x00, 0xAD, 0x00, 0x01, 0xEC, 0xC8, 0x00, 0x00, 0x00</data>
            </entry>
            <entry>
                <type>PRIMITIVE_SEQUENCE</type>
                <id>0</id>
                <data>0x54, 0x00, 0x00, 0xAD, 0x00, 0x06, 0xB0, 0xA0, 0x01, 0x00, 0xB2, 0x00, 0xB1, 0xA0, 0xFA, 0x00, 0x83, 0x20, 0x50, 0x48, 0x43, 0x4D</data>
            </entry>
            <entry>
                <type>PRIMITIVE_SEQUENCE</type>
                <id>1</id>
                <data>0x54, 0x00, 0x00, 0xAD, 0x00, 0x04, 0x83, 0x08, 0x80, 0x00, 0x00, 0x00, 0x87, 0x18, 0x06, 0x80, 0x00, 0x00, 0x83, 0x08, 0xFC, 0x00, 0x00, 0x00, 0x84</data>
            </entry>
            <entry>
                <type>PRIMITIVE_SEQUENCE</type>
                <id>5</id>
                <data>0x54, 0x00, 0x00, 0xAD, 0x00, 0x02, 0xB0, 0xA0, 0x01, 0x00</data>
            </entry>
            <entry>
                <type>PRIMITIVE_SEQUENCE</type>
                <id>2</id>
                <data>0x54, 0x00, 0x00, 0xAD, 0x00, 0x0C, 0x83, 0x08, 0x80, 0x00, 0x00, 0x00, 0x87, 0x18, 0x00, 0x80, 0x00, 0x00, 0x83, 0x08, 0x18, 0x00, 0x00, 0x00, 0xA0, 0xD0, 0x20, 0xB0, 0xA0, 0x01, 0x00, 0xB0, 0xA0, 0x01, 0x00, 0xB2, 0x00, 0xB1, 0xA0, 0xFA, 0x00, 0x83, 0x20, 0x50, 0x48, 0x43, 0x4D</data>
            </entry>
            <entry>
                <type>PRIMITIVE_SEQUENCE</type>
                <id>3</id>
                <data>0x54, 0x00, 0x01, 0x01, 0x04, 0x01, 0x0B, 0x00, 0xAD, 0x00, 0x07, 0x83, 0x08, 0x80, 0x00, 0x00, 0x00, 0x87, 0x18, 0x00, 0x00, 0x00, 0x00, 0xAD, 0x1E, 0x02, 0x83, 0x08, 0x02, 0x00, 0x00, 0x00, 0x88, 0x83, 0x08, 0x00, 0x00, 0x00, 0x00, 0x88, 0x83, 0x08, 0xE0, 0x00, 0x00, 0x00, 0xA0, 0xF0, 0x0A</data>
            </entry>
            <entry>
                <type>PRIMITIVE_SEQUENCE</type>
                <id>4</id>
                <data>0x54, 0x00, 0x01, 0x01, 0x04, 0x01, 0x0B, 0x00, 0xAD, 0x00, 0x06, 0x83, 0x08, 0x80, 0x00, 0x00, 0x00, 0x87, 0x18, 0x00, 0x00, 0x00, 0x00, 0x83, 0x08, 0x00, 0x00, 0x00, 0x00, 0x88, 0x83, 0x08, 0xE0, 0x00, 0x00, 0x00, 0xA0, 0xE0, 0x15</data>
            </entry>
            <entry>
                <type>PRIMITIVE_SEQUENCE</type>
                <id>8</id>
                <data>0x54, 0x00, 0x01, 0x01, 0x04, 0x01, 0x0B, 0x00, 0xAD, 0x00, 0x06, 0x83, 0x08, 0x80, 0x00, 0x00, 0x00, 0x87, 0x18, 0x00, 0x00, 0x00, 0x00, 0x83, 0x08, 0x00, 0x00, 0x00, 0x00, 0x88, 0x83, 0x08, 0xE0, 0x00, 0x00, 0x00, 0xA0, 0xE0, 0x15</data>
            </entry>
            <entry>
                <type>D_ICSP</type>
                <data type="PIC_FLASH_BASE_W">0x00000000</data>
                <data type="PIC_EEPROM_BASE_W">0xFFFFFFFF</data>
                <data type="PIC_USER_ID_BASE_W">0x00008000</data>
                <data type="PIC_CONFIG_BASE_W">0x00008007</data>
                
                <data type="PIC_FLASH_SIZE_W">0x00001000</data>
                <data type="PIC_EEPROM_SIZE_B">0</data>
                <data type="PIC_USER_ID_SIZE_W">4</data>
                <data type="PIC_CONFIG_SIZE_W">5</data>
                
                <data type="PIC_FLASH_WRITE_BLOCK_B">64</data>
                <data type="PIC_EEPROM_WRITE_BLOCK_B">0</data>
                <data type="PIC_USER_ID_WRITE_BLOCK_B">2</data>
                <data type="PIC_CONFIG_WRITE_BLOCK_B">2</data>
                
                <data type="PIC_DEVICE_ID">0x30E8</data>
            </entry>
        </blob>
    </register>
</deviceconf>